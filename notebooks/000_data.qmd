# Data

```{julia}
using Dates
using Speasy
using PSPAnisotropy
using PSP
using PSPAnisotropy: Wind, PSP, THEMIS
using SpacePhysicsMakie: tplot
import SpaceDataModel
using SpaceDataModel: setmeta, times, Product
using TimeseriesUtilities
using GLMakie
using DataFrames, DimensionalData
```

### Parker Solar Probe

- [PSP/FIELDS Level 2 and higher data](https://fields.ssl.berkeley.edu/data/), [SPDF - Coordinated Data Analysis Web (CDAWeb)](https://cdaweb.gsfc.nasa.gov/cgi-bin/eval2.cgi?dataset=PSP_FLD_L2_MAG_RTN&index=sp_phys)

The parameters are:

- 'psp_fld_l2_mag_RTN_4_Sa_per_Cyc' (B in RTN, 0.25s resolution)
- 'psp_swp_spi_sf00_L3_DENS' (Ion density, regular resolution)
- 'psp_swp_spi_af00_L3_DENS' (Ion density, burst resolution)
- 'psp_swp_spi_sf00_L3_VEL_RTN_SUN' (velocity in RTN in Sun's frame, regular resolution)
- 'psp_swp_spi_af00_L3_VEL_RTN_SUN' (velocity in RTN in Sun's frame, burst resolution)
- 'psp_swp_spi_sf00_L3_VEL_RTN' (velocity in RTN in spacecraft frame, regular resolution, you need this to calculate current sheet thickness)
- 'psp_swp_spi_af00_L3_VEL_RTN' (velocity in RTN in spacecraft frame, burst resolution, you need this to calculate current sheet thickness)
- 'Tp_spani_b' (Ion parallel and perpendicular ion temperature, regular resolution. Blue (first element in array): parallel, Red: perp)
- 'Tp_spanib_b' (Ion parallel and perpendicular ion temperature, burst resolution. Blue (first element in array): parallel, Red: perp)

Fluxgate Magnetometer, MAG, Data: The time resolution of the MAG time series data varies with instrument mode ranging from 2.289 samples/s to 292.9 samples/s.

https://heliophysicsdata.gsfc.nasa.gov/WS/hdp/1/Spase?ResourceID=spase%3A%2F%2FNASA%2FNumericalData%2FParkerSolarProbe%2FFIELDS%2FMAG%2FLevel2%2FSC%2FFullResolution%2FPT0.003413S

https://heliophysicsdata.gsfc.nasa.gov/WS/hdp/1/Spase?ResourceID=spase://NASA/NumericalData/ParkerSolarProbe/SWEAP/SPAN-I/Level-3/ProtonPartialMoments/VariableCadence.xml.html

<!-- the helium-to-proton abundance ratio ($A_{He} = N_α/N_p × 100\%$, where $N_α$ and $N_p$ are the number densities of helium particles and protons, respectively) -->

```{julia}
tmin = DateTime("2021-01-15")
n_p = PSP.n_spi(tmin, tmin + Day(1))
n_α = PSP.n_alpha(tmin, tmin + Day(1))

A_He = set_meta(n_α ./ n_p .* 100; ylabel="A_He", units="%", scale=identity)

let tmin = DateTime("2021-01-15")
    tvars = (
        PSP.n_spi,
        PSP.n_alpha,
        A_He
    )
    tplot(tvars, tmin, tmin + Day(1))
end
```

Different coordinate frames

```{julia}
tmin = DateTime("2021-01-15")
tvars = [
    spz"cda/PSP_SWP_SPI_SF00_L3_MOM/VEL_RTN_SUN, VEL_SC, VEL_INST, MAGF_SC"...,
    spz"PSP_FLD_L2_MAG_SC_4_SA_PER_CYC/psp_fld_l2_mag_SC_4_Sa_per_Cyc"
]
tplot(tvars, tmin, tmin + Hour(1))
```

"PSP_SWP_SPI_SF00_L3_MOM" ~3.5s resolution

```{julia}
using Discontinuity

tmin = DateTime("2021-01-15")

# Get results from both methods
function get_discontinuity_results(tmin, tmax, B, V)
    @info resolution(B)
    @info resolution(V)
    df_pvi = Discontinuity.ids_finder_PVI(B, V; every=Hour(2))
    df_cvi = Discontinuity.ids_finder_CVI(B, V; every=Hour(2), std_threshold=2)
    df_variance = Discontinuity.ids_finder(B, V; tau=Second(2))
    CVI_ts = CVI(B)
    PVI_ts = PVI(B)
    return (; df_pvi, df_cvi, df_variance, CVI_ts, PVI_ts)
end

function get_discontinuity_results(tmin, tmax, B_prod::Product, V_prod::Product)
    B = DimArray(B_prod(tmin, tmax))
    V = DimArray(V_prod(tmin, tmax))
    return get_discontinuity_results(tmin, tmax, B, V)
end

psp_results = get_discontinuity_results(tmin, tmin + Day(1), PSP.B, PSP.V)
wind_results = get_discontinuity_results(tmin, tmin + Day(1), Wind.B_GSE, Wind.V_GSE_3DP)

# info the number of events
@info "Number of events for PSP" nrow.(getproperty.(Ref(psp_results), (:df_pvi, :df_cvi, :df_variance)))
@info "Number of events for Wind" nrow.(getproperty.(Ref(wind_results), (:df_pvi, :df_cvi, :df_variance)))
```

Test if the CVI and PVI could capture the discontinuities

```{julia}
tmin = DateTime("2021-01-15")
tmax = DateTime("2021-01-16")
B = DimArray(PSP.B(tmin, tmax))
V = DimArray(PSP.V(tmin, tmax))
```

```{julia}
t0 = DateTime("2021-01-15T09:11")
t1 = DateTime("2021-01-15T09:14")
B_subset = tview(B, t0, t1)
V_subset = tview(V, t0, t1)
df_pvi = Discontinuity.ids_finder_PVI(B_subset, V_subset)
df_cvi = Discontinuity.ids_finder_CVI(B_subset, V_subset)
df_variance = Discontinuity.ids_finder(B_subset; tau=Second(16))

CVI_ts = CVI(B_subset)
PVI_ts = PVI(B_subset)

f = Figure(size=(1400, 1000))

tplot(f[1, 1], [B_subset, [CVI_ts, PVI_ts]])

# Plot 3 candidates from PVI method
for i in 1:min(3, nrow(df_pvi))
    plot_candidate(f[2, 1][i, 1], df_pvi[i, :], [PSP.B,])
end
for i in 1:min(3, nrow(df_cvi))
    plot_candidate(f[2, 2][i, 1], df_cvi[i, :], [PSP.B,])
end
for i in 1:min(3, nrow(df_variance))
    plot_candidate(f[2, 3][i, 1], df_variance[i, :], [PSP.B,])
end
f
```


```{julia}
using Random

f = Figure(size=(1400, 1000))
# Plot 3 candidates from PVI method
for i in 1:min(3, nrow(df_pvi))
    plot_candidate(f[i, 1], df_pvi[i, :], [PSP.B, [CVI_ts, PVI_ts]])
end
random_indices = randperm(nrow(df_cvi))[1:min(3, nrow(df_cvi))]
for (plot_idx, i) in enumerate(random_indices)
    plot_candidate(f[plot_idx, 2], df_cvi[i, :], [PSP.B, [CVI_ts, PVI_ts]])
end
random_indices = randperm(nrow(df_variance))[1:min(3, nrow(df_variance))]
for (plot_idx, i) in enumerate(random_indices)
    plot_candidate(f[plot_idx, 3], df_variance[i, :], [PSP.B, [CVI_ts, PVI_ts]])
end

# Add method labels on the left
Label(f[0, 1], "PVI\nMethod", fontsize=14, tellwidth=false)
Label(f[0, 2], "CVI\nMethod", fontsize=14, tellwidth=false)
Label(f[0, 3], "Variance\nMethod", fontsize=14, tellwidth=false)
resize_to_layout!()
f
```

#### The effect of n / τ on the detection

```{julia}
n_events = 6
n = 16
figsize = (n_events * 300, 400)
f = Figure(; size=figsize)
df = Discontinuity.ids_finder_CVI(B, V; std_threshold=2, n=n)
CVI_tmp = CVI(B; n=n)
# rows = rand(eachrow(df), n_events)

# sort by duration
df = sort(dropmissing(df), :duration; rev=true)
rows = eachrow(df)[1:n_events]
@info rows.duration
for (i, row) in enumerate(rows)
    @info getindex.(Ref(row), (:I_max, :index_std, :index_stability, :index_consistency))
    plot_candidate(f[1, i], row, [PSP.B, CVI_tmp])
end
resize_to_layout!()
f
```


```{julia}
n_events = 6
n = 16
figsize = (n_events * 300, 400)
f = Figure(; size=figsize)
df = Discontinuity.ids_finder(B, V; std_threshold=2, tau=Second(n))

# sort by duration
df = sort(dropmissing(df), :duration; rev=true)
rows = eachrow(df)[1:n_events]
@info rows.duration
for (i, row) in enumerate(rows)
    @info getindex.(Ref(row), (:index_std))
    plot_candidate(f[1, i], row, PSP.B)
end
resize_to_layout!()
f
```



```{julia}
f = Figure(size=(1400, 1000))

for (i, n) in enumerate([1, 2, 4, 32])
    df_cvi = Discontinuity.ids_finder_CVI(B, V; std_threshold=2, n=n)
    CVI_tmp = CVI(B; n=n)
    row = rand(eachrow(df_cvi))
    @info getindex.(Ref(row), (:I_max, :index_std, :index_stability, :index_consistency))
    plot_candidate(f[1, i], row, [PSP.B, CVI_tmp])
    f
end
f
```

```{julia}
f = Figure(size=(1400, 1000))

for (i, n) in enumerate([2, 4, 8, 32])
    df = Discontinuity.ids_finder(B, V; std_threshold=2, tau=Second(n))
    row = rand(eachrow(df))
    @info getindex.(Ref(row), (:index_std, :index_stability))
    plot_candidate(f[1, i], row, [PSP.B])
    f
end
f
```


### THEMIS

<!-- 
ARTEMIS:
We use the following data collected by ARTEMIS P1: magnetic fields with a ∼4s spin resolution (Auster et al. 2008), the ion bulk velocity v, and the ion (assumed to be proton) temperature (scalar) Tp calculated from velocity distributions measured at spin resolution by the Electrostatic Analyzer (ESA; McFadden et al. 2008). Being designed for measurements of a hot, rarefied plasma in Earth’s magnetosphere, ESA typically overestimates the proton temperature in the solar wind, because the solar wind proton beam is narrower than ESA’s energy and angular resolution.
TODO: check if the ESA is in solar wind mode
-->

Notes: `thb_peim_t3_magQ` is not accurate in solar wind mode.

```{julia}
let tmin = DateTime("2021-01-15")
    tvars = (
        THEMIS.B_GSE,
        THEMIS.B_FGL_GSE,
        THEMIS.n,
    )
    tplot(tvars, tmin, tmin + Day(1))
end
```


## Wind

### Wind 3D Plasma Analyzer

> The Wind 3DP instrument consists of six different sensors. There are two electron (EESA) and two ion (PESA) electrostatic analyzers with different geometrical factors and field-of-views covering the energy range from 3 eV to 30 keV. There are also a pair of solid state telescopes (SST) that measure electrons with energies up to 400 keV and protons with energie...

Wind 3dp, PESA LOW 1 spin resolution ion (proton and alpha) moments

Instrument Description

```{julia}
let tmin = DateTime("2021-01-15"), add_unit = false
    tvars = (
        Wind.V_GSE_K0,
        Wind.V_GSE_3DP,
        [
            SpeasyProduct("WI_K0_SWE/Np"; labels=["Proton"]),
            SpeasyProduct("WI_PM_3DP/P_DENS"; labels=["Proton (3DP, PESA Low)"]),
            SpeasyProduct("WI_H1_SWE/Proton_Np_nonlin", labels=["Proton (non-linear fitting)"]),
            SpeasyProduct("WI_H1_SWE/Alpha_Na_nonlin", labels=["Alpha (non-linear fitting)"]),
            Wind.n_e
        ],
    )
    tplot(tvars, tmin, tmin + Hour(3))
end
```


`Wind.V_GSE_3DP` ("WI_PM_3DP/P_VELS") has higer time resolution than `Wind.V_GSE_K0` ("WI_K0_SWE/V_GSE").

`Wind.n_p_nonlin` and `Wind.n_p_K0` seem to be the same.

![](../figures/others/wind.png)

WI_H1_SWE	Proton_W_moment	        Proton thermal speed W (km/s) from isotropic moment analysis
WI_H1_SWE	Proton_Wperp_moment 	Proton thermal speed Wperpendicular (km/s) from bimax moment analysis
WI_H1_SWE	Proton_Wpar_moment	    Proton thermal speed Wparallel (km/s) from bimax moment analysis

WI_H1_SWE	Proton_Wperp_nonlin	    Proton thermal speed perpendicular to the magnetic field direction [km/s].
WI_H1_SWE	Proton_Wpar_nonlin	    Proton thermal speed parallel to the magnetic field direction [km/s].
WI_PLSP_3DP	Ion omnidirectional fluxes 0.4-3 keV and moments, often at ~24 second resolution, PESA Low, Wind 3DP
WI_PM_3DP	Ion moments (computed on-board) @ 3 second (spin) resolution, PESA LOW, Wind 3DP


### SOLO

"cda/SOLO_L2_MAG-RTN-NORMAL-1-MINUTE/B_RTN",
"cda/SOLO_L2_SWA-PAS-GRND-MOM/N",
"cda/SOLO_L2_SWA-PAS-GRND-MOM/V_RTN",
"cda/SOLO_L2_SWA-PAS-GRND-MOM/T",


### STEREO


"cda/STA_L2_PLA_1DMAX_1MIN/proton_number_density",
"cda/STA_L2_PLA_1DMAX_1MIN/proton_bulk_speed",
"cda/STA_L2_PLA_1DMAX_1MIN/proton_n_s_flow_angle_inst",
"cda/STA_L2_PLA_1DMAX_1MIN/proton_e_w_flow_angle_inst",
"cda/STA_L2_PLA_1DMAX_1MIN/proton_Vr_RTN",

## Anisotropy Data

# Anisotropy

- PSP_SWP_SPI_SF00_L3_MOM
    
    - Notes: Partial moments of the Proton distribution function in the SPAN-Ion instrument, PSP spacecraft, and RTN coordinate systems. User should be aware that the full ion distribution is typically NOT in the FOV of the instrument.

    - `T_TENSOR`  Partial Moment Temperature Tensor in instrument frame


- WI_H0_SWE
    
    - `Te_anisotropy`	Temperature anisotropy = Te_para / Te_perp

- WI_PLSP_3DP
    
    - `MOM.P.MAGT3`	---> [P.SYMM_MAGT3] Proton temperature tensor... rotated into a field-aligned coordinate basis and then taking the diagonal elements only

- WI_ELM2_3DP : Wind 3dp, PESA Low (~24 sec resolution) energy spectra with ion moments 
    
    - `MAGT3`	---> [MAGT3] electron temperature tensor... rotated into a field-aligned coordinate basis and then taking the diagonal elements only

- THB_L2_ESA

    - `thb_peeb_magt3Q`	-----Electron Temperature, Field Aligned (Tprp1FA, Tprp2FA, TparFA)

    - `thb_peef_magt3Q`	-----Electron Temperature, Field Aligned (Tprp1FA, Tprp2FA, TparFA)

    - `thb_peif_magt3Q`	-----Temperature, Field Aligned (TprpFA1, TprpFA2, TparFA)

- THB_L2_MOM
	
    - `thb_peem_ptens_magQ`	-----Electron Pressure Tensor, Field Aligned

    - `thb_peem_t3_magQ`	-----Electron Temperature, Field Aligned (TprpFA1, TprpFA2, TparFA)

    - `thb_peim_ptens_magQ`	-----Ion Pressure Tensor, Field Aligned
    
    - `thb_peim_t3_magQ`	-----Ion Temperature, Field Aligned (TprpFA1, TprpFA2, TparFA)