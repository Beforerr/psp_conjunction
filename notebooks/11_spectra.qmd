# Cross helicity and residual energy

```{julia}
using Dates
using PSPAnisotropy
using PSPAnisotropy: Wind
using SPEDAS
using DimensionalData
using Unitful
using PlasmaFormulary
using TimeseriesUtilities
Unitful.preferunits(u"nA", u"km")
```

## Global (whole interval) average


```{julia}

tmin = DateTime("2007-07-06")
tmax = tmin + Hour(1)
B = DimArray(Wind.B_GSE(tmin, tmax); add_unit=true)
V = DimArray(Wind.V_GSE_3DP(tmin, tmax); add_unit=true) |> dropna
n = DimArray(Wind.n_p_3DP(tmin, tmax); add_unit=true) |> dropna
# B, V, n = SPEDAS.tsync(B, V, n)
```


```{julia}
using LinearAlgebra
using Statistics
using SPEDAS.Tullio
using TimeseriesUtilities.VectorizedStatistics

function fast_cross_helicity(B, V, n)
    N = size(B, 1)
    @tullio V_B[i, j] := Alfven_velocity(B[i, j], n[i], 1)
    @tullio B̄[j] := V_B[i, j]
    @tullio V̄[j] := V[i, j]
    B̄ .= B̄ ./ N
    V̄ .= V̄ ./ N
    @tullio num := (V_B[i, j] - B̄[j]) * (V[i, j] - V̄[j])
    @tullio den := (V_B[i, j] - B̄[j]) * (V_B[i, j] - B̄[j]) + (V[i, j] - V̄[j]) * (V[i, j] - V̄[j])
    return 2 * num / den
end

@b fast_cross_helicity(B, V, n), cross_helicity(B, V, n)
```


## Cross helicity and residual energy spectra

<a href="https://docs.juliadsp.org/stable/periodograms/">Periodograms - periodogram estimation · DSP.jl</a>


<a href="https://github.com/lootie/Multitaper.jl">lootie/Multitaper.jl: A Julia package for frequency domain analysis of time series</a>

[pmtm - Multitaper power spectral density estimate - MATLAB](https://www.mathworks.com/help/signal/ref/pmtm.html)

Example spectra of Ev, Eb, and Er, calculated over a 2 day interval (2007 July 6 00:00:00–2007 July 8 00:00:00) using the kinetic normalization, are shown in Figure 1.

```{julia}
using Dates
using DSP
using PSPAnisotropy
using PSPAnisotropy: Wind
using SPEDAS
using Unitful

tmin = DateTime("2007-07-06")
tmax = DateTime("2007-07-08")
B = Wind.B_GSE(tmin, tmax)
V = Wind.V_GSE_3DP(tmin, tmax) |> dropna
n = Wind.n_p_3DP(tmin, tmax) |> dropna
```

```{julia}

V_B = Alfven_velocity.(tsync(B, n)...)

z_pm = PlasmaFormulary.Elsässer.(tsync(V, B, n)...)
z_plus, z_minus = getindex.(z_pm, 1), getindex.(z_pm, 2)
```

```{julia}
"""
    trace_pgram(f, x; kwargs...)

Compute the trace (sum over components) power spectral density of a multi-component time series. Returns a `Periodogram` object with trace power spectral density
"""
function trace_pgram(f, x; fs=nothing, kwargs...)
    # Compute periodogram for each component and sum
    fs = something(fs, samplingrate(x) / 1u"Hz")
    pgrams = map(eachcol(x)) do col
        f(col; fs, kwargs...)
    end
    trace_power = sum(power, pgrams)
    # Return periodogram with trace power and same frequency grid
    return DSP.Periodograms.Periodogram(trace_power, freq(pgrams[1]))
end

```


```{julia}
V_B_pxx_mt = trace_pgram(mt_pgram, ustrip(V_B))

V_pxx = trace_pgram(periodogram, ustrip(V .|> u"m/s"))
V_pxx_mt = trace_pgram(mt_pgram, ustrip(V .|> u"m/s"))
z_plus_pxx_mt = trace_pgram(mt_pgram, ustrip(z_plus))
z_minus_pxx_mt = trace_pgram(mt_pgram, ustrip(z_minus))
```

```{julia}
using CairoMakie

function plot_pxx_pxx_mt!(ax, pxx, pxx_mt; step=10, linewidth=2, alpha=0.8)
    # Get frequency and power data
    freqs_pxx = freq(pxx)
    powers_pxx = power(pxx)
    freqs_mt = freq(pxx_mt)
    powers_mt = power(pxx_mt)

    p1 = lines!(ax, freqs_pxx[2:step:end], powers_pxx[2:step:end]; label="Periodogram", linewidth, alpha)
    p2 = lines!(ax, freqs_mt[2:step:end], powers_mt[2:step:end]; label="Multitaper", linewidth, alpha)
    axislegend(ax, position=:lt)
    return p1, p2
end

function plot_pxx_pxx_mt(pxx, pxx_mt; kw...)
    f = Figure(size=(800, 600))
    ax = Axis(f[1, 1],
        xlabel="Frequency (Hz)",
        ylabel="Power Spectral Density",
        xscale=log10,
        yscale=log10,
        title="Comparison of Power Spectral Density Methods"
    )
    plot_pxx_pxx_mt!(ax, pxx, pxx_mt; kw...)
    return f
end

plot_pxx_pxx_mt(V_pxx, V_pxx_mt)
```


```{julia}
"""
    parker_spiral_direction(r_au; Ω=2.87e-6, V_sw=400e3)

Compute the expected Parker spiral magnetic field direction at distance r_au from the Sun.

Arguments:
- `r_au`: distance from Sun in AU
- `Ω`: solar rotation rate [rad/s] (default: 2.87e-6 rad/s)
- `V_sw`: solar wind speed [m/s] (default: 400 km/s)

Returns:
- Unit vector in Parker spiral direction (radial, tangential, normal components)
"""
function parker_spiral_direction(r_au; Ω=2.87e-6, V_sw=400e3)
    r = r_au * 1.496e11  # convert AU to meters

    # Parker spiral angle
    φ = atan(Ω * r / V_sw)

    # Unit vector: (radial, tangential, normal)
    B_parker = [cos(φ), -sin(φ), 0.0]
    return B_parker / norm(B_parker)
end

"""
    rectify_magnetic_field(B, r_au=1.0)

Rectify magnetic field direction based on Parker spiral to ensure consistent
z+ (outward) and z- (inward) Alfvén wave identification.

Arguments:
- `B`: N×3 magnetic field array
- `r_au`: distance from Sun in AU (default: 1.0)

Returns:
- `B_rect`: rectified magnetic field with consistent Parker spiral alignment
"""
function rectify_magnetic_field(B, r_au=1.0)
    B_parker = parker_spiral_direction(r_au)
    B_rect = copy(B)

    for i in 1:size(B, 1)
        B_vec = B[i, :]
        # Check if B is aligned with Parker spiral (dot product > 0)
        if dot(B_vec, B_parker) < 0
            # Flip B direction if anti-aligned with Parker spiral
            B_rect[i, :] = -B_vec
        end
    end

    return B_rect
end
```


```{julia}
# Plot comparison of Elsasser variable spectra
f = Figure(size=(1200, 800))

step = 10

ax3 = Axis(f[1, 1],
    xlabel="Frequency (Hz)",
    ylabel="Power Spectral Density",
    xscale=log10,
    yscale=log10
)

ax4 = Axis(f[1, 2],
    xlabel="Frequency (Hz)",
    ylabel="Power Spectral Density",
    xscale=log10,
    yscale=log10
)

plot_spectras!(ax3, V_B_pxx_mt, V_pxx_mt; labels=["B", "V"], step=step, linewidth=2, alpha=0.8)
axislegend(ax3, position=:lt)
xlims!(ax3, (1e-4, 5e-1))
ylims!(ax3, (1e6, 1e13))


plot_spectras!(ax4, z_plus_pxx_mt, z_minus_pxx_mt; labels=["z+ (Outward)", "z- (Inward)"], step=step, linewidth=2, alpha=0.8)
axislegend(ax4, position=:lt)
xlims!(ax4, (1e-4, 5e-1))
ylims!(ax4, (1e6, 1e13))

f
```

The spectra of residual energy Er, cross helicity Ec, total energy Et, normalized residual energy σr, normalized cross helicity σc, Alfv ́en ratio rA, and Elsasser ratio rE were then calculated,

$$
\begin{gathered}
E_{\mathrm{r}}=E_{\mathrm{v}}-E_{\mathrm{b}}, \\
E_{\mathrm{c}}=E_{+}-E_{-}, \\
E_{\mathrm{t}}=E_{\mathrm{v}}+E_{\mathrm{b}}, \\
\sigma_{\mathrm{r}}=\frac{E_{\mathrm{v}}-E_{\mathrm{b}}}{E_{\mathrm{v}}+E_{\mathrm{b}}}=\frac{r_{\mathrm{A}}-1}{r_{\mathrm{A}}+1}, \\
\sigma_{\mathrm{c}}=\frac{E_{+}-E_{-}}{E_{+}+E_{-}}=\frac{r_{\mathrm{E}}-1}{r_{\mathrm{E}}+1}, \\
r_{\mathrm{A}}=\frac{E_{\mathrm{v}}}{E_{\mathrm{b}}}=\frac{1+\sigma_{\mathrm{r}}}{1-\sigma_{\mathrm{r}}}, \\
r_{\mathrm{E}}=\frac{E_{+}}{E_{-}}=\frac{1+\sigma_{\mathrm{c}}}{1-\sigma_{\mathrm{c}}} .
\end{gathered}
$$


```{julia}
"""
    compute_sigma(v, B, rho, dt; NW=4)

Compute normalized cross‐helicity σ_C(f) and normalized residual energy σ_R(f)
as functions of frequency.

Returns
  • f      : frequency vector [Hz]
  • σ_C    : normalized cross‐helicity at each f
  • σ_R    : normalized residual energy at each f
"""
function compute_sigma(v::AbstractMatrix, B::AbstractMatrix, rho::AbstractVector, dt::Real; NW::Real=4)
    # fluctuations
    δv, δb = compute_fluctuations(v, B, rho)

    # trace PSDs
    f, E_v = trace_psd_mt(δv, dt; NW=NW)
    _, E_b = trace_psd_mt(δb, dt; NW=NW)

    # build z± and get their trace PSD
    zplus = δv .+ δb
    zminus = δv .- δb
    _, E_p = trace_psd_mt(zplus, dt; NW=NW)
    _, E_m = trace_psd_mt(zminus, dt; NW=NW)

    # normalized cross‐helicity σ_C = (E₊ – E₋)/(E₊ + E₋)
    σ_C = (E_p .- E_m) ./ (E_p .+ E_m)

    # normalized residual energy   σ_R = (E_v – E_b)/(E_v + E_b)
    σ_R = (E_v .- E_b) ./ (E_v .+ E_b)

    return f, σ_C, σ_R
end
```