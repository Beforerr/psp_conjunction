
## Producing the dataset for one timerange

```{julia}
Speasy.init_cdaweb()
timeranges = get_timerange(7)
tmin, tmax = timeranges[1]
taus = Second.(2 .^ (1:6))
B_p = DimArray âˆ˜ PSP.B_SC
```

```{julia}
timeranges = get_timerange(7)
tmin, tmax = timeranges[1]
tmax = tmin + Day(1)
tau = taus[6]
df = ids_finder(tmin, tmax, PSP.B_SC; tau)
# df= produce(psp_conf, taus, timeranges[1])
```

<!-- 464.596 ms (72275 allocs: 238.104 MiB, 3.73% gc time, without a warmup) -->

Check failed events

```{julia}
# B = PSP.B_SC(tmin, tmax) |> DimArray

time_interval = (DateTime("2021-01-14T11:41:42.440"), DateTime("2021-01-14T11:41:43.430"))
time_interval = (DateTime("2021-01-15T07:27:39.754"), DateTime("2021-01-15T07:28:22.667"))
time_interval = (DateTime("2021-01-14T09:34:44.300"), DateTime("2021-01-14T09:34:51.994"))
time_interval = (DateTime("2021-01-15T12:37:14.741"), DateTime("2021-01-15T12:37:18.008"))
time_interval = (DateTime("2021-01-15T17:19:52.777"), DateTime("2021-01-15T17:19:58.521"))
B_mva_prod = Product(B_p, mva_transform)
tplot([tnorm_combine âˆ˜ B_p, B_mva_prod], time_interval...)
```

Here we randomly check the events to see if we can find any issues. Looks fine for most events.

## Check events with $B_n/B > 0.75$

```{julia}
f = Figure(size=(1800, 1000))
let df = filter_low_mva_quality(@subset(wind_df, :B_n_mva_norm .> 0.75)), ð = wind_conf["B"]
    rows = rand(eachrow(df), min(5, nrow(df)))
    for (plot_idx, row) in enumerate(rows)
        plot_candidate(f[1, plot_idx], row, ð; add_B_mva=true)
    end
end

let df = filter_low_mva_quality(@subset(psp_df, :B_n_mva_norm .> 0.75)), ð = psp_conf["B"]
    rows = rand(eachrow(df), min(5, nrow(df)))
    for (plot_idx, row) in enumerate(rows)
        plot_candidate(f[2, plot_idx], row, ð; add_B_mva=true)
    end
end
delete_legends!(f[1:2,1:4])
f
```

## Check events with duration larger than 30 seconds

```{julia}
(Ã˜let df = dropmissing(psp_df, :duration)
    long_events = df[df.duration.>Second(30), :]
    println("Found $(nrow(long_events)) events with duration > 30 seconds")

    if nrow(long_events) > 0
        println("Long duration events:")
        for row in eachrow(long_events)
            println("Time: $(row.time), Duration: $(row.duration), (Fitting duration: $(row.duration_fit))")
        end
    else
        println("No events found with duration > 30 seconds")
    end

    f = Figure(size=(1800, 1000))
    rows = rand(eachrow(long_events), min(5, nrow(long_events)))
    for (plot_idx, i) in enumerate(rows)
        @info "plotting event" i.time i.duration i.duration_fit
        plot_candidate(f[1, plot_idx], i, B_p; add_B_mva=true, add_fit=true)
    end
    f
end
```


We can see that the duration is best defined as the minimum of fitting duration `duration` (which sometimes overestimates the duration when the upstream or downstream over-shoots), or the duration between `t_us` and `t_ds` (which sometimes overestimates the duration when the upstream or downstream is is quite stable).


## Check events with duration shorter than 3 seconds

```{julia}
dt = Second(50)
map((psp_df, wind_df), timeranges) do _df, _tr
    df = dropmissing(_df, :duration)
    short_events = df[df.duration.<dt, :]
    n = nrow(short_events)
    occurence_rate = n / Float64(uconvert(u"d", _tr[2] - _tr[1]))
    println("Found $n events with duration < $dt")
    println("Occurence rate: $occurence_rate")
end

